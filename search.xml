<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http协议的相关知识点</title>
      <link href="/2019/09/01/http/"/>
      <url>/2019/09/01/http/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;协议：不同的硬件，操作系统之间的通信，所有的这一切都需要一种规则。而我们酒吧这种规则称为协议(protocol)。</p></blockquote><p>&emsp;&emsp;协议中存在各式各样的内容。从电缆的规格到ip地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及web页面显示需要处理的步骤，等等。<br><br>&emsp;&emsp;像这样把与互联网相关联的协议集合起来总称为TCP/IP.也有说法认为，TCP/IP是指TCP和IP这两种协议。还有一种说法认为，TCP/IP是在IP协议的通信过程中，使用到的协议族的统称。(PPPoe,DNS,UDP,FTP,HTTP,SNMP,IP,ICMP,TCP,FDDI,IEEE 802.3等协议);</p><p>  <strong>注: TCP/IP 是互联网相关的各类协议族的总称,TCP/IP协议族按层次分别分为以下4层：应用层，传输层，网络层和数据链路层。 </strong></p><h1 id="使用http协议访问web"><a href="#使用http协议访问web" class="headerlink" title="使用http协议访问web"></a>使用http协议访问web</h1><p>&emsp;&emsp;你通过wifi连接电脑上网浏览网址，通过一个域名搜索一个网站，首先是浏览器缓存里面是否存在对应的ip，如果没有，则查看host里面是否存在之前解析的ip(如果你之前访问过该网站的话),如果也没有，则会查看路由器的缓存，如果还不存在，就会去看ISP DNS(客户端电脑上设置的首选DNS服务器)缓存，如果都不存在，则本地dns服务器会将请求转发到互联网上的根域服务器获取dns解析域名，客户端电脑由此获取服务端的ip地址，之后把访问请求通过层次关系后传给路由(网关)，路由根据ip地址查看自身的路由表（静态路由表和动态路由表），通过点对点法则（和交换机的广播不同，广播是一对多）将请求发送给该路由已知的下一个路由（局部最优路径），之后下一个路由也根据路由表转发该请求，直到传到目的ip地址。服务端接到请求后，根据你发送的请求将固定的页面按同样的方法发送给你。</p><h1 id="返回结果的http状态码"><a href="#返回结果的http状态码" class="headerlink" title="返回结果的http状态码"></a>返回结果的http状态码</h1><p>&emsp;&emsp;点击<a href="https://blog.csdn.net/unbreakablec/article/details/87377400" target="_blank" rel="noopener">http错误码大全</a>详情了解</p><h1 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h1><h2 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h2><p>&emsp;&emsp;按层次分，IP(Internet protocol)网际协议位于网络层。Internet Protocol这个名称可能听起来有点夸张，但试试正是如此，几乎所有使用网络的系统都会用到IP协议。可能会有人把“IP”和“IP地址”搞混,“IP”其实是一种协议的名称。<br>&emsp;&emsp;IP地址指明了节点被分配到的地址，MAC地址是只网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会变。</p><p>&emsp;&emsp;IP间的通信依赖MAC地址。在网络上，通信的双方在同意局域网(LAN)内的情况是很少的，通常是经过多台计算机和网络设备中转才能链接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议(Address Resolution Protocol).ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><h2 id="与http协议协作的web服务器"><a href="#与http协议协作的web服务器" class="headerlink" title="与http协议协作的web服务器"></a>与http协议协作的web服务器</h2><h3 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h3><p>&emsp;&emsp;http通信时，除客户端和服务器外，还有一些用于通信数据 转发的应用程序，例如代理，网关和隧道，他们可以配合服务器工作。<br>&emsp;&emsp;这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的相应再转发给客户端。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>&emsp;&emsp;代理是一种有转发功能的应用程序，他扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同事也接收服务器返回的相应并转发给客户端。</p><p><strong>注:后端使用代理服务器可以很大限度的减少安全隐患防止黑客攻击，减轻服务器负担(如缓存服务器)，不仅仅是后端使用，用户可以用代理来“翻墙”，控制用户访问网站的权限，同时也可以部分防止黑客入侵。</strong></p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>&emsp;&emsp;网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非http协议服务，在客户端和网关的通信线路上加密能提高通信的安全性(比如，网关可以连接数据库，使用sql语句查询数据，另外在web购物网站上信用卡结算时，网关可以和信用卡结算系统联动。)<br>&emsp;&emsp;路由器就是一个网关。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>&emsp;&emsp;隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信链接的应用程序。<br>&emsp;&emsp;隧道可按照要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全通信。</p><hr><h2 id="URI-URL和URN的区别"><a href="#URI-URL和URN的区别" class="headerlink" title="URI,URL和URN的区别"></a>URI,URL和URN的区别</h2><blockquote><p>&emsp;&emsp;网上解释的太多太杂了，说了这么一大串怕是连自己都弄糊涂了，所以博主这里总结一遍</p></blockquote><p>关于URL：</p><blockquote><p>&emsp;&emsp;URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置</p></blockquote><p>关于URN:</p><blockquote><p>&emsp;&emsp;URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源</p></blockquote><p>&emsp;&emsp;// 例子: <a href="http://bitpoetry.io/posts/hello.html#intro" target="_blank" rel="noopener">http://bitpoetry.io/posts/hello.html#intro</a></p><p>http:// 定义如何访问资源的方式</p><p>&emsp;&emsp;bitpoetry.io/posts/hello.html 资源存放的位置</p><p>#intro 资源</p><p>&emsp;&emsp;URL是URI的一个子集，告诉我们访问网络位置的方式<br>&emsp;&emsp;<a href="http://bitpoetry.io/posts/hello.html" target="_blank" rel="noopener">http://bitpoetry.io/posts/hello.html</a></p><p>&emsp;&emsp;URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式<br>&emsp;&emsp;bitpoetry.io/posts/hello.html#intro</p><p>&emsp;&emsp;URI(统一资源标识符)其实就是URL+URN，URL又叫做统一资源定位符，是URI的一种。详情点击<a href="https://blog.csdn.net/f45056231p/article/details/82530984" target="_blank" rel="noopener">URL、URI和URN三者之间的区别</a></p><h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p>&emsp;&emsp;HTTP协议中没有加密机制，但可以通过和SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security，安全传输层协议)的组合使用，加密HTTP的通信内容。<br>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS(HTTP secure,超文本传输安全协议)或HTTP over SSL。</p><h2 id="web的攻击技术"><a href="#web的攻击技术" class="headerlink" title="web的攻击技术"></a>web的攻击技术</h2><h3 id="在客户端即可篡改请求"><a href="#在客户端即可篡改请求" class="headerlink" title="在客户端即可篡改请求"></a>在客户端即可篡改请求</h3><p>&emsp;&emsp;在web应用中，从浏览器那接收到的http请求的全部内容，都可以在客户端自由地变更篡改。所以web应用可能会接收到与预期数据不相同的内容。<br><br>&emsp;&emsp;在http请求报文内加载攻击代码，就能发起对web应用的攻击。通过url查询字段或表单，http首部，cookie等途径把攻击代码传入，若这时web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。</p><h3 id="针对web应用的攻击模式"><a href="#针对web应用的攻击模式" class="headerlink" title="针对web应用的攻击模式"></a>针对web应用的攻击模式</h3><ul><li>主动攻击  <p>&emsp;&emsp;主动攻击是指攻击者通过直接访问web应用，将攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。<br>主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。</p></li></ul><p><strong>SQL注入攻击(SQL Injection)</strong><br><br>&emsp;&emsp;SQL注入是指针对web应用使用的数据库，通过运行非法的SQL而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。<br>web应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加，删除等操作时，会使用SQL语句链接数据库进行特定的操作。如果在调用SQL语句的方式上存在疏漏，就有可能执行被恶意注入非法SQL语句。<br>SQL注入攻击有可能会造成以下等影响。</p><blockquote><p>非法查看或篡改数据库内的数据<br><br>规避认证<br><br>执行和数据库服务器业务关联的程序等</p></blockquote><p><strong>OS命令注入攻击(OS Command Injection)</strong><br><br>&emsp;&emsp;OS命令注入攻击是指通过web应用执行非法的操作系统命令达到攻击的目的。只要在能调用shell函数的地方就有存在被攻击的风险。<br><br>&emsp;&emsp;可以从web应用中通过shell来调用操作系统命令。倘若调用shell时存在疏漏，就可以执行插入的非法OS命令。</p><hr><ul><li><p>被动攻击</p>  <p>&emsp;&emsp;被动攻击是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标web应用访问发起攻击。  如：</p><blockquote><p>第一步：攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。<br>第二步：当用户不知不觉中招之后，用户的浏览器或者邮件客户端就会触发这个陷阱。<br>第三步：中招后的用户浏览器会把含有攻击代码的http请求发送给作为攻击目标的web应用，运行攻击代码。<br>第四步：执行完攻击代码，存在安全漏洞的web应用会成为攻击者的跳板，可能导致用户所持的cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p></blockquote><p><strong>跨站脚本攻击(Cross-Site Scripting,XSS)</strong><br><br>&emsp;&emsp;跨站脚本攻击是指通过存在安全漏洞的web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。<br><br>&emsp;&emsp;跨站脚本攻击有可能造成以下影响。</p></li></ul><blockquote><p>1.利用虚假输入表单骗取用户个人信息。<br><br>2.利用脚本窃取用户的cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。<br><br>3.显示伪造的文章或图片。</p></blockquote><p>  <strong>跨站点请求伪造(Cross-Site Request Forgeries,CSRF)</strong><br><br>  &emsp;&emsp;跨站点请求伪造攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。<br><br>  &emsp;&emsp;跨站点请求伪造有可能会造成以下等影响。</p><blockquote><p>1.利用已通过认证的用户权限更新设定信息等<br><br>2.利用已通过认证的用户权限购买商品<br><br>3.利用已通过认证的用户权限在留言板上发表言论</p></blockquote><p><strong>HTTP首部注入攻击(HTTP Header Injection)</strong><br><br> &emsp;&emsp; HTTP首部注入攻击是指攻击者通过在相应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。<br>&emsp;&emsp;向首部主体内添加内容的攻击称为<strong>HTTP响应截断攻击(HTTP Response Splitting Attack)</strong><br><br> &emsp;&emsp;HTTP首部注入攻击有可能造成以下影响。</p><blockquote><p>1.设置任何Cookie信息<br><br>2.重定向至任意URL<br><br>3.显示任意的主体(HTTP响应截断攻击)</p></blockquote><p><strong>HTTP响应截断攻击(HTTP Response Splitting Attack)</strong><br><br>&emsp;&emsp;HTTP相应截断攻击是用在HTTP首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的唤醒就可做出HTTP首部与主体分割所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做HTTP响应截断攻击。<br>&emsp;&emsp;利用这个攻击，已触发陷阱的用户浏览器会显示伪造的web页面，再让用户输入自己的个人信息等，可达到和跨站脚本攻击相同的效果。<br>&emsp;&emsp;另外，滥用HTTP/1.1中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为<strong>缓存污染</strong>。使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的web网页。</p><hr><h3 id="其他攻击方式"><a href="#其他攻击方式" class="headerlink" title="其他攻击方式"></a>其他攻击方式</h3><p><strong>邮件首部注入攻击(Mail Header Injection)</strong><br><br>&emsp;&emsp;邮件首部注入是指web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的web网站，可对任意邮件地址发送广告邮件或病毒邮件。</p><p><strong>目录遍历攻击(Directory Traversal)</strong><br><br>&emsp;&emsp;目录遍历攻击也叫路径遍历攻击(Path Traversal)攻击。通过web应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用../等相对路径定位到/etc/passed等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就可能非法浏览，篡改或删除web服务器上的文件。<br><br>&emsp;&emsp;固然存在输出值转义的问题，但更应该关闭制定对任意文件名的访问权限。</p><p><strong>远程文件包含漏洞(Remote File Inclusion)</strong><br><br>&emsp;&emsp;远程文件包含漏洞是指当部分脚本内容需要从其他文件读入时，攻击这利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。<br><br>&emsp;&emsp;这主要是PHP存在的安全漏洞，对PHP的include或require来说，这是一种可通过设定，指定外部服务器的url作为文件名的功能。但是，该功能太危险，PHP5.2.0之后默认设定此功能无效。<br>&emsp;&emsp;固然存在输出值转义的问题，但更应控制对任意文件名的指定。</p><p><strong>点击劫持(Clickjacking)</strong><br><br>&emsp;&emsp;点击劫持是指利用透明的按钮或链接做成陷阱，覆盖在web页面之上、然后有事用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为<strong>界面伪装(UI Redressing)</strong></p><p><strong>Dos攻击(Denial of Service attack)</strong><br><br>&emsp;&emsp;Dos攻击是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。Dos攻击的对象不仅限于web网站，还包括网络设备及服务器等。<br><br>&emsp;&emsp;主要有一下两种Dos攻击方式。</p><ul><li>集中利用访问请求造成元过载，资源用尽的同事，实际上服务也就呈停止状态。</li><li>通过攻击安全漏洞使服务停止。</li></ul><p>&emsp;&emsp;多台计算机发起的Dos攻击称为DDoS攻击(Distributed Denial of Service attack)。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。</p><h3 id="因设置或设计上的权限引发的安全漏洞"><a href="#因设置或设计上的权限引发的安全漏洞" class="headerlink" title="因设置或设计上的权限引发的安全漏洞"></a>因设置或设计上的权限引发的安全漏洞</h3><ul><li>强制浏览</li><li>不正确的错误消息处理</li><li>开放重定向</li></ul><h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><ul><li>会话劫持</li><li>会话固定攻击</li></ul><h3 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h3><ul><li>开发截断作为Debug调用的后门程序</li><li>开发者为了自身利益植入的后门程序</li><li>攻击者通过某种方法设置的后门程序</li></ul><h3 id="其他安全漏洞"><a href="#其他安全漏洞" class="headerlink" title="其他安全漏洞"></a>其他安全漏洞</h3><h4 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h4><ul><li><p>通过网络的密码试错</p><ul><li>穷举法<ul><li>字典攻击(字典攻击是指利用实现手机号的候选密码（经过这种祝贺方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。)</li></ul></li></ul></li><li><p>对已加密密码的破解(指攻击这入侵系统，疑惑得加密或散列处理的密码数据的情况)<br></p><blockquote><p>web应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加salt的手段对要保存的密码本身加密。那及时攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式。</p><ul><li>通过穷举法/字典攻击进行类推</li><li>彩虹表</li><li>拿到密钥</li><li>加密算法的漏洞</li></ul></blockquote></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>&emsp;&emsp;本篇博客的部分重要内容来源于《图解HTTP》(【日】上野 宣著 于均良 译)。</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络原理 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于kali linux的安装教程踩坑建议</title>
      <link href="/2019/08/29/kalilinux/"/>
      <url>/2019/08/29/kalilinux/</url>
      
        <content type="html"><![CDATA[<h1 id="关于kali-linux的安装教程踩坑建议"><a href="#关于kali-linux的安装教程踩坑建议" class="headerlink" title="关于kali linux的安装教程踩坑建议"></a>关于kali linux的安装教程踩坑建议</h1><blockquote><p>&emsp;&emsp;关于kali linux的u盘物理机安装教程网上信息很少,所以博主在此开个教程贴记录一下博主所遇到的困难。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;对于kali linux的用途和重要性这里就不需要再多次阐述了,对于网络编程网络攻防网络安全都具有非常重要的意义。</p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="第一步-下载kali-linux-镜像iso文件"><a href="#第一步-下载kali-linux-镜像iso文件" class="headerlink" title="第一步 下载kali linux 镜像iso文件"></a>第一步 下载kali linux 镜像iso文件</h2><p>&emsp;&emsp;点击kali linux官网下载,官网有好几个版本,简化版,标准版,剩下的四个版本都是打包的不同的gui界面系统,mate,kde。这里博主下载的是kde桌面版的kali linux。同时下载<a href="https://www.kali.org/downloads/" target="_blank" rel="noopener">kali官网</a>推荐的u盘启动制作工具<a href="https://en.softonic.com/download/universal-usb-installer/windows/post-download" target="_blank" rel="noopener">Universal-USB-Installer-1.9.8.8</a></p><p> <img src="/2019/08/29/kalilinux/1.png" alt="版本下载"></p><h2 id="第二步-制作u盘启动"><a href="#第二步-制作u盘启动" class="headerlink" title="第二步  制作u盘启动"></a>第二步  制作u盘启动</h2><p>&emsp;&emsp;将iso镜像文件导入到Universal-USB-Installer-1.9.8.8工具中制作中制作u盘启动盘。</p>  <strong>&emsp;&emsp;注意：这里u盘将会被分区,使用并隐藏部分空间用作引导系统,所以会出现u盘容量就算格式化后也不会达到原来的容量,若你想恢复到原来的容量就可以使用DiskGenius工具删除分区恢复到原来容量。 </strong><h2 id="第三步-修改电脑启动项"><a href="#第三步-修改电脑启动项" class="headerlink" title="第三步 修改电脑启动项"></a>第三步 修改电脑启动项</h2>  <p>&emsp;&emsp;如果你的电脑是win10系统,就可以 win+x 在在安全与更新中找到恢复,在恢复中找到高级设置,选择重启。如果不是win10系统,那么请在网上搜索对应的进入bios系统的文章,一般来讲都是在开机启动时不停按住f12键</p>  <p>&emsp;&emsp;重启之后在设置里面,进入到bios设置中。</p>  <p>&emsp;&emsp;在bios中更改启动项,修改为usb启动项,详细请百度自己主板的型号,不同主板的设置略有不同。</p><h2 id="第四步-安装"><a href="#第四步-安装" class="headerlink" title="第四步 安装"></a>第四步 安装</h2>  <p>&emsp;&emsp;将u盘插入到电脑上,电脑重启中u盘引导系统打开kali linux安装界面,选择grapical install安装,也可以选择install,两者的区别是一个是图形界面安装一个是文字界面安装,安装后的区别是一样的。</p>  <p>&emsp;&emsp;注意：如果你用的是大白菜或者Win32DiskImager工具制作的u盘启动盘,大白菜pe系统会提醒你解压后再安装,但解压后会找不到gho文件,如果你用的是Win32DiskImager工具,使用grapical install会导致黑屏,却可以使用install文字界面安装,博主暂时不清楚文字界面安装是否可以成功。(博主没有试过老毛桃制作,暂时不太清楚,但是网上有人说老毛桃安装也不会成功。)</p><p>&emsp;&emsp;安装完成后就可以进入系统了,注意的是最后一步安装GRUB时,必须选择我们安装系统的那块硬盘,格式是 /dev/ 开头,否则会出现安装后启动黑屏的情况。</p><h2 id="第五步-基础设置"><a href="#第五步-基础设置" class="headerlink" title="第五步 基础设置"></a>第五步 基础设置</h2><h3 id="更改更新源网址"><a href="#更改更新源网址" class="headerlink" title="更改更新源网址"></a>更改更新源网址</h3><p>&emsp;&emsp;因为下载源的本地地址是在/etc/apt/sources.list,所以我们先打开终端输入cd /etc/apt 进入文件,pwd是查看当前路径,然后ls是查看当前路劲下的所有文件,然后我们输入 leafpad sources.list,表示用leafpad(系统自带文本编辑器)打开sources.list,然后我们可以百度地址源复制进文件中,保存退出。然后在终端输入</p><pre><code>apt-get update //更新源ape-get upgrade //更新软件apt-get dist-upgrade //更新系统 //清除安装包apt-get clean apt-get autoclean </code></pre><p><img src="/2019/08/29/kalilinux/2.png" alt="更新下载源"></p><h3 id="安装google浏览器"><a href="#安装google浏览器" class="headerlink" title="安装google浏览器"></a>安装google浏览器</h3><p>&emsp;&emsp;在终端中输入指令</p><pre><code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code></pre> <p>&emsp;&emsp;将下载的文件包解压安装</p><pre><code>dpkg -i google-chrome-stable_*.deb    </code></pre><p>&emsp;&emsp;此时会因为缺少依赖包报错,修复安装</p><pre><code>apt-get -f install</code></pre><p>&emsp;&emsp;安装谷歌浏览器依赖包</p><pre><code>apt-get install google-chrome-stable</code></pre><p>&emsp;&emsp;重新解压安装</p><pre><code>dpkg -i google-chrome-stable_*.deb    </code></pre><p>&emsp;&emsp;然后我们点击谷歌图标打开浏览器,发现没有反应。<br><br>&emsp;&emsp;怎么办？别慌！<br><br>&emsp;&emsp;我们安装完成以后需要修改 /user/share/applications 桌面图标文件 .desktop,</p><p>&emsp;&emsp;用图形界面打开 /user/share/applications 找到谷歌浏览器图标,右击查看属性。</p><p>&emsp;&emsp;将： </p><pre><code>/usr/bin/google-chrome-stable %U</code></pre><p>&emsp;&emsp;替换为：</p><pre><code>/usr/bin/google-chrome --no-sandbox --user-data-dir</code></pre><p>&emsp;&emsp;再点击图标就能顺利打开谷歌浏览器了。</p><p>   &emsp;&emsp;注意:用终端打开google浏览器的命令是 </p><pre><code>google-chrome-stable --no-sandbox</code></pre><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p>&emsp;&emsp;百度即可,这里推荐一个网址<a href="https://blog.csdn.net/qq_39338006/article/details/80659853" target="_blank" rel="noopener">点击即可</a></p><h3 id="安装截屏scrot"><a href="#安装截屏scrot" class="headerlink" title="安装截屏scrot"></a>安装截屏scrot</h3><p>&emsp;&emsp;输入指令 apt-get install scrot</p><p><img src="/2019/08/29/kalilinux/3.png" alt="安装scrot"></p><p>&emsp;&emsp;主要指令:</p><pre><code>scrot   // 截取整个桌面scrot /root/Pictures/l.png  // 指定保存目标文件夹和截图文件名(默认保存当前目录下)scrot -s   // 截取特定窗口或矩形区域 </code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>   <p>&emsp;&emsp;有时更新</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
          <category> kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> kali </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序人脸动态识别摇头点头采坑建议</title>
      <link href="/2019/08/23/BaiDuface/"/>
      <url>/2019/08/23/BaiDuface/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>&emsp;&emsp;应需求,在小程序内部弄一个人脸动态活体扫描,检测一下摇摇头,点点头之类的。但是在网上的相关信息却没有,偶尔有几个思路,所以就在这里记录下自己的探究历程</p></blockquote><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&emsp;&emsp;首先说明的是这篇文章采用的是百度云的人脸识别,与腾讯的人脸识别不同的是,百度人脸识别的api还提供三维旋转的角度检测,这样对于实现检测人脸识别摇头和点头是非常简单的。</p><p><img src="/2019/08/23/BaiDuface/first.png" alt="百度云人脸识别接口说明"></p><h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>&emsp;&emsp;创造一个定时器,在定时器里面使用拍照之后使用人脸识别接口,这样就变成动态检测了。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setTimeout和setInterval区别及选择"><a href="#setTimeout和setInterval区别及选择" class="headerlink" title="setTimeout和setInterval区别及选择"></a>setTimeout和setInterval区别及选择</h4>  <p>&emsp;&emsp;setTimeout和setInterval都可以用作定时器,但是我们得先大致区分一下两者的部分区别:</p><blockquote><p>&emsp;&emsp;setTimeout会保证在指定好的延时时间后执行,但是setInterval则不会这样。 如果function中的代码有耗时载操作,那么使用setTimeout方法递归,则可能会增加总递归的时间。 <br><br>&emsp;&emsp;而使用setInterval方法,如果程序中耗时比延时间隔长,则会立刻回调函数。( 更多关于setInterval计时不准确可以点击<a href="https://www.zhihu.com/question/20479535" target="_blank" rel="noopener">这里</a>了解。)</p></blockquote><p>&emsp;&emsp;因为setInterval计时并不准确,同时我们定时器同时存在耗时操作(调用百度云接口),所以我们这里就采用setTimeout +递归方式来实现定时。</p><h4 id="定时器代码"><a href="#定时器代码" class="headerlink" title="定时器代码"></a>定时器代码</h4><pre><code>every_camera_upload: function(acstoken) { //定时拍摄照片let that = this;timer = setTimeout(function() {//设置定时器,并赋给全局变量timer //that.camera().then(resx =&gt; {//循环拍照     // that.uploadBaiDuPicture(acstoken).then(rx =&gt;{//上传百度云接口     // that.judge_face(rx);//获取返回的json数据并分析   // });    that.every_camera_upload(that.data.getAccessToken); //方法中调用定时器实现循环//  });}, 1500);}//clearTimeout(timer); //此方法不能放在定时器方法内部,//用于清除新一轮循环中函数还未运行时清除定时器,//也不能放在every_camera_upload()方法内部,应为要重复调用,应放于其他方法内部。</code></pre><p>&emsp;&emsp;解释一下代码,在方法内部,设置一个setTimeout赋给全局变量,在定时器内部调用camer方法,之后则重复调用every_camera_upload()方法实现递归。clearTimeout()的作用用于清除循环,必须在其他方法中使用。</p><h2 id="实现功能过程"><a href="#实现功能过程" class="headerlink" title="实现功能过程"></a>实现功能过程</h2><h3 id="获取accessToken"><a href="#获取accessToken" class="headerlink" title="获取accessToken"></a>获取accessToken</h3><p>&emsp;&emsp;阅读百度云人脸识别接口得知,先获取access_token进行身份验证,但我们不能将密钥密匙放在客户端上防止别人抓包逆工程获取到,此时可以将其放在服务器或者使用云开发的云函数上(博主使用的云函数)</p><h4 id="云函数代码"><a href="#云函数代码" class="headerlink" title="云函数代码"></a>云函数代码</h4><pre><code>// 云函数入口文件 const cloud = require(&apos;wx-server-sdk&apos;); cloud.init();// 云函数入口函数var getAccessToken = function () { //人脸识别APIvar https = require(&apos;https&apos;);var qs = require(&apos;querystring&apos;);const param = qs.stringify({&apos;grant_type&apos;: &apos;client_credentials&apos;,&apos;client_id&apos;: &apos;你的 Api Key&apos;,&apos;client_secret&apos;: &apos;你的 Secret Key&apos;});var access_token;return new Promise((resolve,reject) =&gt; { let body =[];https.get({  hostname: &apos;aip.baidubce.com&apos;,  path: &apos;/oauth/2.0/token?&apos; + param,  agent: false},function (res) {  res.on(&apos;data&apos;,(chunk) =&gt; {    body.push(chunk);  });   res.on(&apos;end&apos;, () =&gt;{    let data = Buffer.concat(body).toString();    let getData = JSON.parse(data);     access_token = getData.access_token;    console.log(access_token);    resolve(access_token);  });     } );}).then(res =&gt;{return access_token;});}exports.main = (event, context) =&gt; { let datas = getAccessToken();  return datas;}</code></pre><h4 id="小程序端代码"><a href="#小程序端代码" class="headerlink" title="小程序端代码"></a>小程序端代码</h4><pre><code>getAccessToken: function() { //获取accesstoken var x = new Promise((resolve, reject) =&gt; {  wx.cloud.callFunction({    name: &apos;getBaiDuAccessToken&apos;,    data: {},    success: resy =&gt; {      console.log(resy);      console.log(resy.result);      resolve(resy.result);    },    fail: resy =&gt; {      wx.showToast({        title: &apos;accesstoken报错&apos;,        icon: &apos;none&apos;,        duration: 2000      });    }  });});return x; }</code></pre><h3 id="开始定时循环拍摄"><a href="#开始定时循环拍摄" class="headerlink" title="开始定时循环拍摄"></a>开始定时循环拍摄</h3><p>&emsp;&emsp;获取到access_token后,就可以在小程序循环拍摄上传了,但注意的是access_token最好放在服务器上让小程序将照片发送到后端让后端发送请求接口,但考虑到诸多性能问题,博主就将其放在小程序端上。</p><h4 id="循环拍照"><a href="#循环拍照" class="headerlink" title="循环拍照"></a>循环拍照</h4><pre><code>every_camera_upload: function(acstoken) { //定时拍摄照片  let that = this; timer = setTimeout(function() {  that.camera().then(resx =&gt; {    that.uploadBaiDuPicture(acstoken).then(rx =&gt;{      that.judge_face(rx);    });    that.every_camera_upload(that.data.getAccessToken); //方法中调用定时器实现循环  });}, 1500);</code></pre><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>&emsp;&emsp;发送请求最好由服务器来做,服务器解析之后返回给小程序端,博主将其放在小程序端。</p><pre><code>uploadBaiDuPicture: function(restoken) { //上传百度云照片并解析  var base64 = wx.getFileSystemManager().readFileSync(this.data.tempImagePath, &apos;base64&apos;);  let data = [{ //百度云的锅,在json格式外需要外加一个[]    image: base64,    image_type: &apos;BASE64&apos; }];return new Promise((resolve, reject) =&gt; {  wx.request({    url: &apos;https://aip.baidubce.com/rest/2.0/face/v3/faceverify?access_token=&apos; + restoken,    data: data,    // dataType: &quot;json&quot;,    method: &apos;POST&apos;,    header: {      &apos;Content-Type&apos;: &apos;application/json&apos;    },    success(res) {      resolve(res);    }  })});}</code></pre> <p>&emsp;&emsp;由于拍摄的照片是在本地上,发送请求就必须将本地照片进行base64编码后放入data请求参数中,特别重要的一点,如果你碰上这种错误返回:</p>   <p> <img src="/2019/08/23/BaiDuface/second.png" alt="接口返回错误222200"></p> <p>&emsp;&emsp;那八成是由于请求参数外没有加 [ ],如上代码显示,json请求格式外要 [] ,这个错误网上信息很少,解释为百度人脸识别v3版本的api表单是个list,接口开发文档也没有相关注明,所以请注意这个坑,引用:<a href="https://ai.baidu.com/forum/topic/show/870349" target="_blank" rel="noopener">活体检测error_code&quot;:222200&quot;</a></p><h3 id="摇头点头顺序设置"><a href="#摇头点头顺序设置" class="headerlink" title="摇头点头顺序设置"></a>摇头点头顺序设置</h3><pre><code>judge_face: function(res) { //判断用户点头摇头动作    let that = this;if (res.data.error_code == 0) {  if (this.data.prove_face_front == false){    that.judge_prove_face_front(res);  }else if (that.data.judge_left_change_right_head_count &lt; 2) {    that.judge_left_change_right_head(res); //判断用户摇头  } else if(that.data.judge_down_to_up_head_count &lt; 2){    that.judge_down_to_up_head(res); //判断用户点头  }else {    wx.showLoading({      title: &apos;上传中&apos;,    });    innerAudioConext.src = &quot;/music/upload.mp3&quot;    innerAudioConext.play();    this.uploadUserPictureProve();    clearTimeout(timer);  }} else if (res.data.error_code == 222202) {  wx.showToast({    title: &apos;未识别到脸部&apos;,    icon: &apos;none&apos;,    duration: 500  });} else {  wx.showToast({    title: &apos;未知错误&apos;,    icon: &apos;none&apos;,    duration: 500  });}</code></pre><p>  }</p><h3 id="解析返回json文件"><a href="#解析返回json文件" class="headerlink" title="解析返回json文件"></a>解析返回json文件</h3> <p>&emsp;&emsp;获取返回的json的参数pitch,yaw,为三维旋转角度,以此判断正脸</p><pre><code>judge_prove_face_front:function(res){  let pitch = Math.abs(res.data.result.face_list[0].angle.pitch);  let yaw = Math.abs(res.data.result.face_list[0].angle.yaw);  if ((pitch &lt; 5 ) &amp;&amp; (yaw&lt;5)) {  let font_face=this.data.tempImagePath  this.setData({    prove_face_front: true,    save_font_face:font_face  })} else {  wx.showToast({    title: &apos;未检测到正脸&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre> <p>&emsp;&emsp;播放语音,获取返回的json的参数yaw,用上一次获取的yaw减去这一次的yaw参数的绝对值判断是否摇头。</p><pre><code>judge_left_change_right_head: function(res) {   if (this.data.music_count == 0) {     innerAudioConext.src = &quot;/music/leftright.mp3&quot;     innerAudioConext.play();     this.data.music_count++;}let yaw = parseInt(res.data.result.face_list[0].angle.yaw);if ((yaw &lt; 0 || yaw &gt; 0) &amp;&amp; (Math.abs(this.data.last_yaw - yaw)&gt;40)) {  this.data.judge_left_change_right_head_count++;  this.setData({    last_yaw: yaw  })  console.log(&quot;摇头 &quot; + this.data.judge_left_change_right_head_count)} else {  console.log(&quot;yaoyaoyoa  &quot; + parseInt(this.data.last_yaw - yaw));  console.log(&quot;yaoyaoyoa  &quot; + typeof (res.data.result.face_list[0].angle.yaw));  wx.showToast({    title: &apos;未检测到摇头&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre> <p>&emsp;&emsp;播放语音,获取返回的json的参数pitch,用上一次获取的pitch减去这一次的pitch参数的绝对值判断是否点头。</p><pre><code>judge_down_to_up_head: function(res) {if(this.data.music_count==1){  innerAudioConext.src = &quot;/music/headupdown.mp3&quot;  innerAudioConext.play();  this.data.music_count++;}let pitch = res.data.result.face_list[0].angle.pitch;if ((pitch &lt; 0 || pitch &gt; 0) &amp;&amp; (Math.abs(this.data.last_pitch - pitch) &gt; 5.5)) {  this.data.judge_down_to_up_head_count++;  this.setData({    last_pitch: pitch  })  //console.log(&quot;点头 &quot; + this.data.judge_down_to_up_head_count)} else { // console.log(&quot;点头 &quot; + this.data.judge_down_to_up_head_count) // console.log(&quot;点头ssssssssss &quot; + Math.abs(this.data.last_pitch - pitch))  wx.showToast({    title: &apos;未检测到点头&apos;,    icon: &apos;none&apos;,    duration: 1000  });}}</code></pre><h3 id="人脸对比"><a href="#人脸对比" class="headerlink" title="人脸对比"></a>人脸对比</h3>   <p>&emsp;&emsp;所有验证成功后,就可以直接上传人脸对比了,关于人脸对比同样使用静默人脸对比,由于源码解释众多,本篇文章就不再重复讲解了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>   <p>&emsp;&emsp;只看开发者文档注定会踩许多坑,希望能将有坑的地方记录下来,让更多人注意。感谢其他文章论坛提问的帮助,链接如下：<br>&emsp;&emsp;<a href>微信小程序—setTimeOut定时器的坑</a><br>&emsp;&emsp;<a href="https://ai.baidu.com/forum/topic/show/870349" target="_blank" rel="noopener">活体检测error_code&quot;:222200&quot;</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程平台 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> javascript </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序循环同步请求踩坑指南</title>
      <link href="/2019/08/13/Mini-Program/"/>
      <url>/2019/08/13/Mini-Program/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序循环同步请求踩坑指南"><a href="#微信小程序循环同步请求踩坑指南" class="headerlink" title="微信小程序循环同步请求踩坑指南"></a>微信小程序循环同步请求踩坑指南</h1><br><blockquote><p>&emsp;&emsp;最近做微信小程序校园失物巡回箱的时候需要完成一个逻辑就是用循环while/for 来不断向云数据库发送读写请求，有感而写，希望能给你启发。</p></blockquote><br><h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>&emsp;&emsp;关于不断循环发送请求这一点，由于发送请求本是耗时操作，本意打算用promise来将异步变成同步，但试过之后发现循环只运行一次，原因尚不清楚。可能是由于js的线程堵塞机制引发的阻塞问题，</p><h2 id="展示代码"><a href="#展示代码" class="headerlink" title="展示代码"></a>展示代码</h2><h3 id="promse请求"><a href="#promse请求" class="headerlink" title="promse请求"></a>promse请求</h3><p>故障:只能运行一次</p><pre><code>onLoad:function(){  for (let i=0;i&lt;9;i++){     return new Promise((resolve,reject) =&gt;{            //执行代码成功            resolve();            //执行代码失败            reject();     }).then(res =&gt;{});   }}</code></pre><h3 id="async-await请求"><a href="#async-await请求" class="headerlink" title="async await请求"></a>async await请求</h3><p>解决只能与逆行一次的问题</p><pre><code> async onLoad(){  for(let i=0;i&lt;9;i++){      await new Promise((resolve,reject) =&gt;{            //执行代码成功            resolve();            //执行代码失败            reject();     }).then(res =&gt;{});  }}</code></pre><h2 id="js阻塞机制"><a href="#js阻塞机制" class="headerlink" title="js阻塞机制"></a>js阻塞机制</h2><h3 id="阻塞机制解释"><a href="#阻塞机制解释" class="headerlink" title="阻塞机制解释"></a>阻塞机制解释</h3><p>&emsp;&emsp;JavaScript是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是Ajax请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。<br>&emsp;&emsp;关键说明：假如当前 JavaScript线程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</p><p>&emsp;&emsp;js阻塞机制，跟Js引擎的单线程处理方式有关，每个window一个JS线程。所谓单线程，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。</p>以下给个示例:<pre><code>for(var i=0;i&lt;3;i++){  setTimeout(function(){      console.log(i);                  }, (i+1)*1000); }</code></pre><p>&emsp;&emsp;一般，我们会认为，这段代码会log出来0,1,2.而实际上，这段代码log出来的结果是 3,3,3。具体原因就是因为for循环的阻塞机制。在上面的代码中，setTimeout这个定时器需要等待for循环 执行完成，而for循环执行完成了之后，i已经为3了，此时才开始执行setTimeout，因此console.log(i)会是3。至于为什么i会是3,当i为2的时候，满足循环条件，执行代码块，然后i++，此时i为3，不满足循环条件，不执行代码块，循环停止。</p><h3 id="阻塞机制解决办法"><a href="#阻塞机制解决办法" class="headerlink" title="阻塞机制解决办法"></a>阻塞机制解决办法</h3><p>&emsp;&emsp;其实，阻塞作为js引擎的处理方式，我们最好不要想着解决“阻塞”，而是让我们想执行的代码，插入到“主线程”中。这么说比较不易理解，还是以上面的代码为例，直接上代码好了</p><pre><code>for(var i=0;i&lt;3;i++){  (function(i){      setTimeout(function(){        console.log(i);          }, (i+1)*1000);      })(i) }</code></pre><p>&emsp;&emsp;在上面的代码中，我们加了一个立即执行的匿名函数，并且将for循环的i作为实参传入进去。这样，setTimeout就会被立即执行，而不会等待（这里不太了解细节，就不多说了，大概猜测为新开了一个临时的线程，立即执行匿名函数，然后再立即切换回来）。</p><p>注意：顺带提一下，html5支持Web worker功能，可以写多线程，小程序同样可以用worker功能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>&emsp;&emsp;本篇文章引用的文章链接如下，感谢他们的帮助:</p>&emsp;&emsp; <a href="https://blog.csdn.net/rangwotongxing34/article/details/79378790" target="_blank" rel="noopener">JavaScript的单线程与阻塞式执行（附案例）</a><p>&emsp;&emsp; <a href="https://www.cnblogs.com/hq233/p/8042995.html" target="_blank" rel="noopener">Js中for循环的阻塞机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程平台 </category>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的监听设备上网教程(fiddler抓包)</title>
      <link href="/2019/08/06/get-talk/"/>
      <url>/2019/08/06/get-talk/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的监听设备上网教程"><a href="#一个简单的监听设备上网教程" class="headerlink" title="一个简单的监听设备上网教程"></a>一个简单的监听设备上网教程</h1><blockquote><p>&emsp;&emsp;由于网络诈骗盗号层出不穷，谣言止于智者，所以给大家开始普及网络攻防安全。先从最基础的网络说起，这是第一版教程，之后回陆续介绍一下其他的方法。</p></blockquote><br><h2 id="责任申明"><a href="#责任申明" class="headerlink" title="责任申明"></a>责任申明</h2><p>&emsp;&emsp;本篇博客原创仅供学习交流使用，如用作其他用途所承受的法律责任一概与作者无关。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p> &emsp;&emsp;由于是最初教程，首先给大家大致普及一下互联网的通讯，从广泛的http通讯说起吧。</p><blockquote><p>&emsp;&emsp;你通过wifi连接电脑上网浏览网址，通过一个域名搜索一个网站，首先是浏览器缓存里面是否存在对应的ip，如果没有，则查看host里面是否存在之前解析的ip(如果你之前访问过该网站的话),如果也没有，则会查看路由器的缓存，如果还不存在，就会去看ISP DNS(客户端电脑上设置的首选DNS服务器)缓存，如果都不存在，则本地dns服务器会将请求转发到互联网上的根域服务器获取dns解析域名，客户端电脑由此获取服务端的ip地址，之后把访问请求通过层次关系后传给路由(网关)，路由根据ip地址查看自身的路由表（静态路由表和动态路由表），通过点对点法则（和交换机的广播不同，广播是一对多）将请求发送给该路由已知的下一个路由（局部最优路径），之后下一个路由也根据路由表转发该请求，直到传到目的ip地址。服务端接到请求后，根据你发送的请求将固定的页面按同样的方法发送给你。</p></blockquote><h2 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h2><p> 前提条件：<br><br>&emsp;&emsp;你和你要监听对象是连在同一个网络中的(比如: wifi网络).<br>&emsp;&emsp;此处笔者模拟的是在手机连在电脑的一个热点下电脑端监听聊天.(注:如果是统一wifi下，你可以登录家庭路由器的网址在路由设置里面更改代理(部分路由器可能没有端口镜像或端口监控功能),代理所填写的ip是你抓取别人上网数据的设备的ip，如果没有路由器代理功能，手机上wifi模式下长按连接的wifi选择高级选项，在里面填写代理和监听端口.<br>  <br></p><h2 id="第一步-下载fiddler"><a href="#第一步-下载fiddler" class="headerlink" title="第一步 下载fiddler"></a>第一步 下载fiddler</h2><p>  &emsp;&emsp;在百度上搜索fiddler下载，<a href="https://www.baidu.com/link?url=PNiuANjLE32GLkoC_yZd4JC2ugEFhvLsD_GUQ_66oYV5IfotNo3uR5sb6eiSrvcP&wd=&eqid=d4505bdf00123fd3000000065d4bb5f4" target="_blank" rel="noopener">fiddler官网</a> <br><br>  &emsp;&emsp;下载完成之后打开<br>  &emsp;&emsp;界面是这样的：<br>  <img src="/2019/08/06/get-talk/1.png" alt="fiddler界面截图"></p><h2 id="第二步-设置抓包选项"><a href="#第二步-设置抓包选项" class="headerlink" title="第二步 设置抓包选项"></a>第二步 设置抓包选项</h2><p>   &emsp;&emsp;在主界面左上角tools选择options界面 </p><p>   <img src="/2019/08/06/get-talk/2.png" alt="options界面"><br><br><br>   &emsp;&emsp;按照如图更改：<br>   <br><br>    <img src="/2019/08/06/get-talk/3.png" alt="更改HTTPS设置"><br>    <br><br>&emsp;&emsp;解释：<br>    &emsp;&emsp;因为fiddler默认只会抓取http协议的请求数据，所以我们选择Capture HTTPS CONNECTs(捕获HTTPS连接),意思是可以捕获https的请求数据会在主界面显示<br><br><br>    <img src="/2019/08/06/get-talk/4.png" alt="更改Connections设置"><br>    <br><br>     &emsp;&emsp;Decrypt HTTPS traffic(解密HTTPS通信),https是加密传输，我们fiddler只有使用中间人攻击才能破译对方上网的数据。</p><blockquote><p>from all processes:来自所有进程<br>  from browsers only:仅从浏览器<br>  from non-browsers only:仅从非浏览器<br>  from remote clients only:仅从远程客户端  </p></blockquote><p>  &emsp;&emsp;如果我们想抓取对方的上网信息，不抓取本地我们自己的上网信息，就可以选择from remote clients only，这样就不会抓到我们自己的数据包了。<br>  &emsp;&emsp;不建议勾选 check for certificate revocation(检查证书是否过期)</p><p>  &emsp;&emsp;非必选：然后选择右方的Actions，选择把证书下载到桌面上。之后需要用。<br>   <br><br>  <img src="/2019/08/06/get-talk/5.png" alt="监听端口设置"><br>  &emsp;&emsp;选择监听端口为8888，选中allow remote computers to connect.</p><h2 id="第三步-手机端配置"><a href="#第三步-手机端配置" class="headerlink" title="第三步 手机端配置"></a>第三步 手机端配置</h2><p> &emsp;&emsp;长按所选wlan<br>   <br></p><p><img src="/2019/08/06/get-talk/6.png" alt="连接wlan"></p><p><img src="/2019/08/06/get-talk/7.png" alt="修改网络"><br> <br><br>&emsp;&emsp;选择修改网络，选中高级设置<br>&emsp;&emsp;代理主机地址之后填写，先填写我们最开始设置的端口号8888<br> <br><br><img src="/2019/08/06/get-talk/8.png" alt="设置代理端口"><br><br><br>&emsp;&emsp;同时，电脑端win+R弹出运行框，输入cmd确定后，在dos界面输入ipconfig，找到如下：<br><br><br> <img src="/2019/08/06/get-talk/9.png" alt="查找代理主机ip"></p><p>&emsp;&emsp;这里的ipv4地址就是手机端要输入的代理主机的地址(内网地址)<br>&emsp;&emsp;之后手机连接电脑：</p><p><img src="/2019/08/06/get-talk/10.png" alt="成功连接"></p><h2 id="第四步-安装CA证书"><a href="#第四步-安装CA证书" class="headerlink" title="第四步 安装CA证书"></a>第四步 安装CA证书</h2><p>&emsp;&emsp;手机打开浏览器，搜索格式为 <strong>你刚刚在手机端填写的代理主机地址</strong>:8888,出现如下界面就证明你离成功就差一步了<br> <img src="/2019/08/06/get-talk/11.png" alt="手机界面"><br> &emsp;&emsp;点击下载FiddlerRoot certificate ，然后安装证书即可。（某些手机可能无法直接安装，需要在设置里面找到用户信任凭证或者证书下安装才可）</p><p> &emsp;&emsp;现在我们再打开fiddler，手机端浏览<a href="github.com">github官网</a>，fiddler抓包效果：</p><p> <img src="/2019/08/06/get-talk/12.png" alt="fiddler抓包"></p><h2 id="最后一点"><a href="#最后一点" class="headerlink" title="最后一点"></a>最后一点</h2>  <p>&emsp;&emsp;关于fiddler抓包qq，微信聊天记录，fiddler只能抓取http/https协议的通信，如果上面没有显示则证明qq微信用的其他通信协议，那么就要去学习其他的抓包软件，如强大且复杂的Wireshark根据自己的理解慎重选择学习。</p>]]></content>
      
      
      <categories>
          
          <category> 网络原理 </category>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> fiddler </tag>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学校教务网的一个安全漏洞</title>
      <link href="/2019/08/05/find-leak/"/>
      <url>/2019/08/05/find-leak/</url>
      
        <content type="html"><![CDATA[<h1 id="发现教务网的一个安全漏洞"><a href="#发现教务网的一个安全漏洞" class="headerlink" title="发现教务网的一个安全漏洞"></a>发现教务网的一个安全漏洞</h1><blockquote><p>&emsp;&emsp;在做一个人脸识别的项目时，需要获取学校教务网上的学生的照片，但是后来我无意中发现学校教务网上的一个安全漏洞，就是在得到自己图片的cookie之后，由于学校的http请求是get请求，并且由于cookie的权限会导致你在持有cookie的情况下可以访问学校任何一个有学号的同学的照片</p></blockquote><br><h2 id="http的get请求和post请求的区别"><a href="#http的get请求和post请求的区别" class="headerlink" title="http的get请求和post请求的区别"></a>http的get请求和post请求的区别</h2><p>&emsp;&emsp;关于这一点,直接把百度的结果粘贴如下:</p><p>&emsp;&emsp;<strong> GET和POST是Http请求中最常用的两种请求方法: </strong></p><blockquote><p>   首先介绍GET与POST的差异:</p><p>   （1）GET请求资源数据，POST向服务器传递需要处理的数据</p><p>  （2）GET传递数据大小不超过2kb，POST没有限制</p><p>  （3）GET请求的参数会在Url上暴露显示，POST请求参数在Requestbody里，所以相对GET来说，POST安全性较高</p><p>  （4）GET 请求的静态资源会被浏览器缓存，POST不会被缓存</p><p>   （5）GET传递的数据类型是文本，POST是文本或者二进制</p><p>   （6）GET请求被回退时是无害的，POST请求被回退是会被重新再执行一次GET和POST的使用场景：  </p><blockquote><p>   （a）在传递一些机密信息时必须要使用POST<br>   （b）只是查询获取数据时可以用GET<br>   （c）POST请求速率会比GET慢，因为GET请求产生一个TCP数据包;POST请求产生两个TCP数据包</p></blockquote></blockquote><hr><br><h2 id="探究过程"><a href="#探究过程" class="headerlink" title="探究过程"></a>探究过程</h2>   <p>&emsp;&emsp;由于get请求的参数会在url暴露显示，我们可以直接更改url上的参数，将学号更改为其他人的学号来获取其他人的照片信息,但是发现这样获取太慢了，就直接写个多线程批量下载照片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;  </span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.HttpURLConnection;  </span><br><span class="line">import java.net.URL;  </span><br><span class="line">  </span><br><span class="line"> public class downimage &#123;  </span><br><span class="line">public static void  downLoadFromUrl(String urlStr,String fileName,String </span><br><span class="line">savePath) throws IOException&#123;</span><br><span class="line">        URL url = new URL(urlStr);  </span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();  </span><br><span class="line">        conn.setConnectTimeout(3*1000); </span><br><span class="line">        System.setProperty(&quot;http.proxyHost&quot;, &quot;localhost&quot;); </span><br><span class="line">        System.setProperty(&quot;http.proxyPort&quot;, &quot;8888&quot;);         </span><br><span class="line">        conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible;</span><br><span class="line"> MSIE 5.0; Windows NT; DigExt)&quot;);</span><br><span class="line">            conn.setRequestProperty(&quot;Cookie&quot;,&quot;semester.id=281;</span><br><span class="line"> JSESSIONID=8F14338919CEA1334F7E4B558217782D; </span><br><span class="line">iPlanetDirectoryPro=vYeKkeVYfd97aWCGmR2lSA&quot;);</span><br><span class="line">        InputStream inputStream = conn.getInputStream();  </span><br><span class="line">        byte[] getData = readInputStream(inputStream);    </span><br><span class="line">        File saveDir = new File(savePath);</span><br><span class="line">        if(!saveDir.exists())&#123;</span><br><span class="line">            saveDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        File file = new File(saveDir+File.separator+fileName);    </span><br><span class="line">        FileOutputStream fos = new FileOutputStream(file);     </span><br><span class="line">        fos.write(getData); </span><br><span class="line">        if(fos!=null)&#123;</span><br><span class="line">            fos.close();  </span><br><span class="line">        &#125;</span><br><span class="line">        if(inputStream!=null)&#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;info:&quot;+url+&quot; download success&quot;); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static  byte[] readInputStream(InputStream inputStream) throws </span><br><span class="line">IOException &#123;  </span><br><span class="line">        byte[] buffer = new byte[1024];  </span><br><span class="line">        int len = 0;  </span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();  </span><br><span class="line">        while((len = inputStream.read(buffer)) != -1) &#123;  </span><br><span class="line">            bos.write(buffer, 0, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">        bos.close();  </span><br><span class="line">        return bos.toByteArray();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    int z=起始学号;</span><br><span class="line">    int y = 结束学号;</span><br><span class="line">    for (int i=起始学号;i&lt;=v结束学号;i++)&#123;</span><br><span class="line">      String filename=y+&quot;.jpg&quot;;</span><br><span class="line">    String x=&quot;网址&quot;+z;//z是学号，由于是get请求</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"> try&#123;</span><br><span class="line">     downLoadFromUrl(x,</span><br><span class="line">         filename,&quot;C:/Users/asus/Desktop/pictures&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    z++;</span><br><span class="line">    y++;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;线程休眠2s,之后直接将图片下载到桌面上的文件夹中，理论上你可以下载所有学生的照片，<del>如果外带一个人脸识别接口判断颜值，就能找到校花了</del> </p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>抓取成果:</p><p><img src="/2019/08/05/find-leak/find-leak.png" alt="成果截图"><br>           &nbsp; &nbsp; &nbsp; ps：为保护隐私，给图片打码。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>&emsp;&emsp;源代码中cookie是需要你手动获取的，在浏览器中打开图片前f12打开浏览器开发者模式,找到含有sessionid的cookie手动填上去。如果觉得麻烦，这里提供一个思路：先用账号密码登录官网，然后用document.cookie获取到cookie，然后包装请求头再次发送给服务器，前提是该cookie没有设置httponly。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2> <p>&emsp;&emsp;本篇博客原创仅供学习交流使用，如用作其他用途所承受的法律责任一概与作者无关。</p>]]></content>
      
      
      <categories>
          
          <category> 安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简易爬虫 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导论</title>
      <link href="/2019/07/30/%E5%AF%BC%E8%AE%BA/"/>
      <url>/2019/07/30/%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="why-blog"><a href="#why-blog" class="headerlink" title="why blog"></a>why blog</h1><blockquote><p>&emsp;&emsp;长久以来一个问题一直困扰着我，为什么有些东西如此昂贵，如此的高科技，却毫无用处，就像我知道的，计算机虽然是台笨机器，却有能力做出难以置信的智能事情，而程序员虽然是一些聪明的人，但却老是做难以置信的傻事情。他们呀，简言之，是对绝配。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;— Bill Bryson, 作家, 出自《Notes from a Big Country》</p></blockquote><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>&emsp;&emsp;针对网络上繁杂的基础知识和实验流程做一个自己总结的简略总结，每个人的思维方式和问题角度，对待问题的着重点不同以至于在网络上看待一个过程，知识点，问题的解决方案每个人所得到的东西都不尽一致。希望自己能尽心尽力地去总结我在学习上遇到的各种困难问题，这样对自己后来的复习和解决新的困难时会更加迅速。</p><h2 id="学习困境"><a href="#学习困境" class="headerlink" title="学习困境"></a>学习困境</h2><p>&emsp;&emsp;需要学习的东西太多，完整消化一个知识点又需要很长时间，比如对于http协议的深入了解还需要去了解交换机局域网的通信原理，在学习过程种所遇到的困难很多，网络上有些存在解决方案但是没有讲授出现问题的原因。况且身边的学习氛围不够浓厚，除非意志坚定很难在一段漫长的时间里保持对学习的高度热情，并且身处群体之中，个体很难维持长久的理智。希望自己能在学习的道路上顽强走下去。</p><h2 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h2><ul><li>wireshark的使用</li><li>完整探究局域网的底层通讯原理</li><li>学习二维码的原理</li><li>框架架构设计模式的根本区别</li><li>了解数据保护</li><li>深入探究web开发流程客户端服务端数据库的三方通讯</li><li>巩固代码基础（java implements）</li><li>修改校园失物巡回箱子的刷新监听代码</li><li>修改校园失物巡回箱子人脸动态活体扫描机制</li><li>抓取学校官网的照片并进行人脸对比</li><li>了解dns劫持</li><li>写http图解的读后感，梳理其中的web攻击方式（博客）</li><li>熟悉安卓的mvp和mvc设计模式</li><li>了解脚本</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>好好学习</p>]]></content>
      
      
      <categories>
          
          <category> 导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode的markdown操作</title>
      <link href="/2019/07/30/vscode%E6%96%87%E6%A1%A3/"/>
      <url>/2019/07/30/vscode%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Vscode-Markdown-相关问题"><a href="#Vscode-Markdown-相关问题" class="headerlink" title="Vscode Markdown 相关问题"></a>Vscode Markdown 相关问题</h2><blockquote><p>关于vscode markdown.styles如何使用自定义css文件的解决方案</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>出现无法加载 “markdown.styles”的显示框</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因:"></a>问题原因:</h3><blockquote><p>根据issue说是安全原因取消了绝对路径样式，以至于现在无法使用绝对路径</p><p><a href="https://github.com/Microsoft/vscode/issues/45260" target="_blank" rel="noopener">https://github.com/Microsoft/vscode/issues/45260</a></p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:  "></a>解决办法: <br> <br></h3><p> &ensp; &ensp;要么使用扩展，要么用当前工作空间的相对路径。就是说你这个css文件相对于当前编辑的文件的位置的路径，如果觉得绕口，就把css文件放在编辑文件的同一个目录下，这样路径直接填css文件名就好了。</p><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程:  "></a>操作过程: <br> <br></h3><p> 第一步在vscode界面的左下角齿轮打开设置，输入markdown</p><p> <img src="/2019/07/30/vscode文档/1.png" alt="第一步"></p><p> 第二步找到Markdown.styles，点击编辑</p><p> <img src="/2019/07/30/vscode文档/2.png" alt="第二步"></p><p> 第三步修改如图， <strong>注意的是你填写的路径如我开头所讲的那样，是你当前编辑文件的相对路径</strong>    </p><p> <img src="/2019/07/30/vscode文档/3.png" alt="第三步"></p><p> 修改完成之后就会看到效果。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
